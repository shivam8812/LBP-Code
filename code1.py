# -*- coding: utf-8 -*-
"""LBP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J4JC_vniWXRHuC4vZqIKihTw_lssFvVK

Installing Modules
"""



"""Importing Modules"""

import networkx as nx
import matplotlib.pyplot as plt
import matplotx
import numpy as np
import random

"""Setting Parameters"""



class interaction_based_model:
  def __init__(self, t, M_L, M_G, p_L, p_G, evap, n, delta):
    self.t = t
    self.M_L = M_L
    self.M_G = M_G
    self.p_L = p_L
    self.p_G = p_G
    self.evap = evap
    self.n = n
    self.delta = delta
    self.G = nx.Graph()
    self.G.add_nodes_from(range(0, n))

  def global_interactions(self, i):
    for x in range(0, self.M_G):
      degrees = [val for (node, val) in self.G.degree()]
      total = sum(degrees)
      prob = [(degree + 1)/ (total + self.n) for degree in degrees]

      u = i

      while u==i:
        u = np.random.choice(np.arange(0, self.n), p=prob)

      temp = np.random.choice(np.arange(0, 2), p = [self.p_G, 1 - self.p_G])

      if temp:
        if self.G.has_edge(u, i):
          self.G[u][i]['weight'] -= self.delta

        else:
          self.G.add_edge(u, i, weight= -1*(self.delta))

      else:
        if self.G.has_edge(u, i):
          self.G[u][i]['weight'] += self.delta

        else:
          self.G.add_edge(u, i, weight=self.delta)

  def local_interactions(self, i):
    for x in range(0, self.M_L):
      random_vertex = i
      adjacent_vertices = [n for n in self.G.neighbors(i)]
      for j in adjacent_vertices:
        if self.G[i][j]['weight'] == 0:
          self.G.remove_edge(i,j)
      if self.G.degree[i]:
        adjacent_vertices = [n for n in self.G.neighbors(i)]
        weight_adjacent_vertices = [abs(self.G[i][neighbour]['weight']) for neighbour in adjacent_vertices]
        total = sum(weight_adjacent_vertices) 
        prob = [x/total for x in weight_adjacent_vertices]
        random_vertex = np.random.choice(adjacent_vertices, p=prob) 
      else:
        lst = [j for j in range(0, self.n)]
        lst.remove(i)
        u = np.random.randint(0, self.n-1)
        random_vertex = lst[u]
        self.G.add_edge(random_vertex, i, weight=0)
      random_vertex2 = random_vertex
      adjacent_vertices = [n for n in self.G.neighbors(random_vertex)]
      adjacent_vertices.remove(i)
      for j in adjacent_vertices:
        if self.G[random_vertex][j]['weight'] == 0:
          self.G.remove_edge(random_vertex,j)
      if self.G.degree[random_vertex]>1:
        adjacent_vertices = [n for n in self.G.neighbors(random_vertex)]
        adjacent_vertices.remove(i)
        adjacent_vertices = [n for n in self.G.neighbors(random_vertex)]
        weight_adjacent_vertices = [abs(self.G[random_vertex][neighbour]['weight']) for neighbour in adjacent_vertices]
        total = sum(weight_adjacent_vertices) 
        prob = [x/total for x in weight_adjacent_vertices]
        random_vertex2 = np.random.choice(adjacent_vertices, p=prob)        
      else:
        lst = [j for j in range(0, self.n)]
        lst.remove(i)
        lst.remove(random_vertex)
        u = np.random.randint(0, self.n-2)
        random_vertex2 = lst[u]
        self.G.add_edge(random_vertex2, random_vertex, weight=0) 

      temp1 = np.random.choice(np.arange(0, 2), p = [self.p_L, 1 - self.p_L])
      
      if temp1:
        self.G[random_vertex][i]['weight'] -= self.delta
      else:
        self.G[random_vertex][i]['weight'] += self.delta

      temp2 = np.random.choice(np.arange(0, 2), p = [self.p_L, 1 - self.p_L])

      if temp2:
        self.G[random_vertex][random_vertex2]['weight'] -= self.delta
      else:
        self.G[random_vertex][random_vertex2]['weight'] += self.delta
      
      temp3 = 1
      if (temp1 == 1 and temp2 == 1) or (temp1 == 0 and temp2 == 0):
        temp3 = 0

      if temp3:
        if self.G.has_edge(random_vertex2, i):
          self.G[random_vertex2][i]['weight'] -= self.delta

        else:
          self.G.add_edge(random_vertex2, i, weight= -1*(self.delta))

      else:
        if self.G.has_edge(random_vertex2, i):
          self.G[random_vertex2][i]['weight'] += self.delta

        else:
          self.G.add_edge(random_vertex2, i, weight=self.delta)

  def evaporation(self):
    thingsToChange = []
    for v1, v2, data in self.G.edges(data=True):
      if abs(self.G[v1][v2]['weight']) <= self.evap:
        thingsToChange.append([v1,v2])
      elif data['weight']>0:
        self.G[v1][v2]['weight'] -= self.evap
      else:
        self.G[v1][v2]['weight'] += self.evap
      
    for thing in thingsToChange:
      self.G.remove_edge(thing[0],thing[1])  

  def main_function(self):
    for n in range(0, self.t):
      for i, data in self.G.nodes(data=True):
        self.global_interactions(i) 
        self.local_interactions(i)  
      if n%10==0:
          print(n)
          print("EV")
      self.evaporation()



"""PLOTTING GRAPHS FOR - 
1. Number of edges and number of positive edges
2. Clustering Coefficient
3. Diameter and average path length
4. Number of triangles and balanced triangles
"""

from statistics import mean
#Varying M_L 
#t, M_L, M_G, p_L, p_G, evap, n, delta
values = [i for i in range(0, 10)]
values2 = [0,1,5]
figure,axis = plt.subplots(2, 2,figsize=(15,15))
sty = ['dashed','dotted','solid']
sty2 = ['o','s']
for j in range(0,len(values2)):
  edge_count = []
  positive_edge_count = []
  clustering_coefficient = []
  diameter_value = []
  avg_path_length= []
  triangle_count = []
  balanced_triangle_count = []
  for i in range(0,len(values)):
    test = interaction_based_model(150, values[i], values2[j], 0.6, 0.9, 0.5, 1000, 1)
    test.main_function()
    edge_count.append(test.G.number_of_edges())
    edges = [(x[2]['weight']) for x in test.G.edges(data=True)]
    pos_count1 = len(list(filter(lambda x: (x >= 0),edges)))
    positive_edge_count.append(pos_count1)
    clustering_coefficient.append(nx.average_clustering(test.G))
    g = [test.G.subgraph(c).copy() for c in nx.connected_components(test.G)]
    dia = 0
    avg = []
    for k in g:
      dia = max(dia,nx.diameter(k))
      avg.append(nx.average_shortest_path_length(k))
    diameter_value.append(dia)
    avg_path_length.append(mean(avg))
    triangle_count.append(sum(nx.triangles(test.G).values())/3)
    triangles = [c for c in nx.cycle_basis(test.G) if len(c)==3]
    triangle_types=[]
    for triangle in triangles:
        tri=nx.subgraph(test.G,triangle)
        triangle_types.append(np.product([(x[2]['weight']) for x in tri.edges(data=True)]))
    pos_count = len(list(filter(lambda x: (x >= 0), triangle_types)))
    balanced_triangle_count.append(pos_count)
  axis[0,0].plot(values,edge_count,linestyle = sty[j],marker = 'o',label = '|E|, M_G = ' + str(values2[j]))
  axis[0,0].plot(values,positive_edge_count,linestyle = sty[j],marker = 's',label = '|E+|, M_G = ' + str(values2[j]))
  axis[0,0].legend()
  axis[0,0].set_xlabel('M_L')
  axis[0,1].plot(values,clustering_coefficient,linestyle = sty[j],marker = 'o',label = 'c, M_G = ' + str(values2[j]))
  axis[0,1].legend()
  axis[0,1].set_xlabel('M_L')
  axis[1,0].plot(values,diameter_value,linestyle = sty[j],marker = 'o',label = 'd, M_G = ' + str(values2[j]))
  axis[1,0].plot(values,avg_path_length,linestyle = sty[j],marker = 's',label = 'l, M_G = ' + str(values2[j]))
  axis[1,0].legend()
  axis[1,0].set_xlabel('M_L')
  axis[1,1].plot(values,triangle_count,linestyle = sty[j],marker = 'o',label = '|\u0394|, M_G = ' + str(values2[j]))
  axis[1,1].plot(values,balanced_triangle_count,linestyle = sty[j],marker = 's',label = '|\u0394_b|, M_G = ' + str(values2[j]))
  axis[1,1].legend()
  axis[1,1].set_xlabel('M_L')

plt.show()

#varying M_G
figure,axis = plt.subplots(2, 2,figsize=(15,15))
sty = ['dashed','dotted','solid']
sty2 = ['o','s']
for j in range(0,len(values2)):
  edge_count = []
  positive_edge_count = []
  clustering_coefficient = []
  diameter_value = []
  avg_path_length= []
  triangle_count = []
  balanced_triangle_count = []
  for i in range(0,len(values)):
    test = interaction_based_model(150, values2[j], values[i], 0.6, 0.9, 0.5, 1000, 1)
    test.main_function()
    edge_count.append(test.G.number_of_edges())
    edges = [(x[2]['weight']) for x in test.G.edges(data=True)]
    pos_count1 = len(list(filter(lambda x: (x >= 0),edges)))
    positive_edge_count.append(pos_count1)
    clustering_coefficient.append(nx.average_clustering(test.G))
    g = [test.G.subgraph(c).copy() for c in nx.connected_components(test.G)]
    dia = 0
    avg = []
    for k in g:
      dia = max(dia,nx.diameter(k))
      avg.append(nx.average_shortest_path_length(k))
    diameter_value.append(dia)
    avg_path_length.append(mean(avg))
    triangle_count.append(sum(nx.triangles(test.G).values())/3)
    triangles = [c for c in nx.cycle_basis(test.G) if len(c)==3]
    triangle_types=[]
    for triangle in triangles:
        tri=nx.subgraph(test.G,triangle)
        triangle_types.append(np.product([(x[2]['weight']) for x in tri.edges(data=True)]))
    pos_count = len(list(filter(lambda x: (x >= 0), triangle_types)))
    balanced_triangle_count.append(pos_count)
  axis[0,0].plot(values,edge_count,linestyle = sty[j],marker = 'o',label = '|E|, M_L = ' + str(values2[j]))
  axis[0,0].plot(values,positive_edge_count,linestyle = sty[j],marker = 's',label = '|E+|, M_L = ' + str(values2[j]))
  axis[0,0].legend()
  axis[0,0].set_xlabel('M_G')
  axis[0,1].plot(values,clustering_coefficient,linestyle = sty[j],marker = 'o',label = 'c, M_L = ' + str(values2[j]))
  axis[0,1].legend()
  axis[0,1].set_xlabel('M_G')
  axis[1,0].plot(values,diameter_value,linestyle = sty[j],marker = 'o',label = 'd, M_L = ' + str(values2[j]))
  axis[1,0].plot(values,avg_path_length,linestyle = sty[j],marker = 's',label = 'l, M_L = ' + str(values2[j]))
  axis[1,0].legend()
  axis[1,0].set_xlabel('M_G')
  axis[1,1].plot(values,triangle_count,linestyle = sty[j],marker = 'o',label = '|\u0394|, M_L = ' + str(values2[j]))
  axis[1,1].plot(values,balanced_triangle_count,linestyle = sty[j],marker = 's',label = '|\u0394_b|, M_L = ' + str(values2[j]))
  axis[1,1].legend()
  axis[1,1].set_xlabel('M_G')
plt.show()

#varying p_L
values = [i/10 for i in range(3, 10)]
values2 = [0.6,0.9]
figure,axis = plt.subplots(2, 2,figsize=(15,15))
sty = ['dashed','dotted','solid']
sty2 = ['o','s']
for j in range(0,len(values2)):
  edge_count = []
  positive_edge_count = []
  clustering_coefficient = []
  diameter_value = []
  avg_path_length= []
  triangle_count = []
  balanced_triangle_count = []
  for i in range(0,len(values)):
    test = interaction_based_model(150,5,1, values[i], values2[j], 0.5, 1000, 1)
    test.main_function()
    edge_count.append(test.G.number_of_edges())
    edges = [(x[2]['weight']) for x in test.G.edges(data=True)]
    pos_count1 = len(list(filter(lambda x: (x >= 0),edges)))
    positive_edge_count.append(pos_count1)
    clustering_coefficient.append(nx.average_clustering(test.G))
    g = [test.G.subgraph(c).copy() for c in nx.connected_components(test.G)]
    dia = 0
    avg = []
    for k in g:
      dia = max(dia,nx.diameter(k))
      avg.append(nx.average_shortest_path_length(k))
    diameter_value.append(dia)
    avg_path_length.append(mean(avg))
    triangle_count.append(sum(nx.triangles(test.G).values())/3)
    triangles = [c for c in nx.cycle_basis(test.G) if len(c)==3]
    triangle_types=[]
    for triangle in triangles:
        tri=nx.subgraph(test.G,triangle)
        triangle_types.append(np.product([(x[2]['weight']) for x in tri.edges(data=True)]))
    pos_count = len(list(filter(lambda x: (x >= 0), triangle_types)))
    balanced_triangle_count.append(pos_count)
  axis[0,0].plot(values,edge_count,linestyle = sty[j],marker = 'o',label = '|E|, p_G = ' + str(values2[j]))
  axis[0,0].plot(values,positive_edge_count,linestyle = sty[j],marker = 's',label = '|E+|, p_G = ' + str(values2[j]))
  axis[0,0].legend()
  axis[0,0].set_xlabel('p_L')
  axis[0,1].plot(values,clustering_coefficient,linestyle = sty[j],marker = 'o',label = 'c, p_G = ' + str(values2[j]))
  axis[0,1].legend()
  axis[0,1].set_xlabel('p_L')
  axis[1,0].plot(values,diameter_value,linestyle = sty[j],marker = 'o',label = 'd, p_G = ' + str(values2[j]))
  axis[1,0].plot(values,avg_path_length,linestyle = sty[j],marker = 's',label = 'l, p_G = ' + str(values2[j]))
  axis[1,0].legend()
  axis[1,0].set_xlabel('p_L')
  axis[1,1].plot(values,triangle_count,linestyle = sty[j],marker = 'o',label = '|\u0394|, p_G = ' + str(values2[j]))
  axis[1,1].plot(values,balanced_triangle_count,linestyle = sty[j],marker = 's',label = '|\u0394_b|, p_G = ' + str(values2[j]))
  axis[1,1].legend()
  axis[1,1].set_xlabel('p_L')
plt.show()

#varying evap
figure,axis = plt.subplots(2, 2,figsize=(15,15))
values = [i/10 for i in range(1, 10)]
values2 = [150,433]
sty = ['dashed','dotted','solid']
sty2 = ['o','s']
lab = ['','M']
for j in range(0,len(values2)):
  edge_count = []
  positive_edge_count = []
  clustering_coefficient = []
  diameter_value = []
  avg_path_length= []
  triangle_count = []
  balanced_triangle_count = []
  for i in range(0,len(values)):
    test = interaction_based_model(values2[j],5,1,0.6,0.9, values[i],1000, 2*values[i])
    test.main_function()
    edge_count.append(test.G.number_of_edges())
    edges = [(x[2]['weight']) for x in test.G.edges(data=True)]
    pos_count1 = len(list(filter(lambda x: (x >= 0),edges)))
    positive_edge_count.append(pos_count1)
    clustering_coefficient.append(nx.average_clustering(test.G))
    g = [test.G.subgraph(c).copy() for c in nx.connected_components(test.G)]
    dia = 0
    avg = []
    for k in g:
      dia = max(dia,nx.diameter(k))
      avg.append(nx.average_shortest_path_length(k))
    diameter_value.append(dia)
    avg_path_length.append(mean(avg))
    triangle_count.append(sum(nx.triangles(test.G).values())/3)
    triangles = [c for c in nx.cycle_basis(test.G) if len(c)==3]
    triangle_types=[]
    for triangle in triangles:
        tri=nx.subgraph(test.G,triangle)
        triangle_types.append(np.product([(x[2]['weight']) for x in tri.edges(data=True)]))
    pos_count = len(list(filter(lambda x: (x >= 0), triangle_types)))
    balanced_triangle_count.append(pos_count)
  axis[0,0].plot(values,edge_count,linestyle = sty[j],marker = 'o',label = '|E|' + lab[j])
  axis[0,0].plot(values,positive_edge_count,linestyle = sty[j],marker = 's',label = '|E+|' + lab[j])
  axis[0,0].legend()
  axis[0,0].set_xlabel('\u03B5')
  axis[0,1].plot(values,clustering_coefficient,linestyle = sty[j],marker = 'o',label = 'c' + lab[j])
  axis[0,1].legend()
  axis[0,1].set_xlabel('\u03B5')
  axis[1,0].plot(values,diameter_value,linestyle = sty[j],marker = 'o',label = 'd' + lab[j])
  axis[1,0].plot(values,avg_path_length,linestyle = sty[j],marker = 's',label = 'l' + lab[j])
  axis[1,0].legend()
  axis[1,0].set_xlabel('\u03B5')
  axis[1,1].plot(values,triangle_count,linestyle = sty[j],marker = 'o',label = '|\u0394|' + lab[j])
  axis[1,1].plot(values,balanced_triangle_count,linestyle = sty[j],marker = 's',label = '|\u0394_b|' + lab[j])
  axis[1,1].legend()
  axis[1,1].set_xlabel('\u03B5')
plt.show()




#varying t
figure,axis = plt.subplots(2, 2,figsize=(15,15))
values = [i for i in range(1, 10)]
values2 = [1,2]
sty = ['dashed','dotted','solid']
sty2 = ['o','s']
lab = ['','M']
edge_count = []
positive_edge_count = []
clustering_coefficient = []
diameter_value = []
avg_path_length= []
triangle_count = []
balanced_triangle_count = []
for j in range(0,len(values)):
  
  test = interaction_based_model(values[j]*100,5,1,0.6,0.9, 0.5,1000, 1)
  test.main_function()
  edge_count.append(test.G.number_of_edges())
  edges = [(x[2]['weight']) for x in test.G.edges(data=True)]
  pos_count1 = len(list(filter(lambda x: (x >= 0),edges)))
  positive_edge_count.append(pos_count1)
  clustering_coefficient.append(nx.average_clustering(test.G))
  g = [test.G.subgraph(c).copy() for c in nx.connected_components(test.G)]
  dia = 0
  avg = []
  for k in g:
    dia = max(dia,nx.diameter(k))
    avg.append(nx.average_shortest_path_length(k))
  diameter_value.append(dia)
  avg_path_length.append(mean(avg))
  triangle_count.append(sum(nx.triangles(test.G).values())/3)
  triangles = [c for c in nx.cycle_basis(test.G) if len(c)==3]
  triangle_types=[]
  for triangle in triangles:
      tri=nx.subgraph(test.G,triangle)
      triangle_types.append(np.product([(x[2]['weight']) for x in tri.edges(data=True)]))
  pos_count = len(list(filter(lambda x: (x >= 0), triangle_types)))
  balanced_triangle_count.append(pos_count)
j = 0
axis[0,0].plot(values,edge_count,linestyle = sty[j],marker = 'o',label = '|E|')
axis[0,0].plot(values,positive_edge_count,linestyle = sty[j],marker = 's',label = '|E+|')
axis[0,0].legend()
axis[0,0].set_xlabel('t')
axis[0,1].plot(values,clustering_coefficient,linestyle = sty[j],marker = 'o',label = 'c')
axis[0,1].legend()
axis[0,1].set_xlabel('t')
axis[1,0].plot(values,diameter_value,linestyle = sty[j],marker = 'o',label = 'd')
axis[1,0].plot(values,avg_path_length,linestyle = sty[j],marker = 's',label = 'l')
axis[1,0].legend()
axis[1,0].set_xlabel('t')
axis[1,1].plot(values,triangle_count,linestyle = sty[j],marker = 'o',label = '|\u0394|')
axis[1,1].plot(values,balanced_triangle_count,linestyle = sty[j],marker = 's',label = '|\u0394_b|')
axis[1,1].legend()
axis[1,1].set_xlabel('t')
plt.show()


#varying n
figure,axis = plt.subplots(2, 2,figsize=(15,15))
values = [i for i in range(1, 10)]
values2 = [1,2]
sty = ['dashed','dotted','solid'] 
sty2 = ['o','s']
lab = ['','M']
edge_count = []
positive_edge_count = []
clustering_coefficient = []
diameter_value = []
avg_path_length= []
triangle_count = []
balanced_triangle_count = []
for j in range(0,len(values)):
  
  test = interaction_based_model(150,5,1,0.6,0.9, 0.5,values[j]*1000, 1)
  test.main_function()
  edge_count.append(test.G.number_of_edges())
  edges = [(x[2]['weight']) for x in test.G.edges(data=True)]
  pos_count1 = len(list(filter(lambda x: (x >= 0),edges)))
  positive_edge_count.append(pos_count1)
  clustering_coefficient.append(nx.average_clustering(test.G))
  g = [test.G.subgraph(c).copy() for c in nx.connected_components(test.G)]
  dia = 0
  avg = []
  for k in g:
    dia = max(dia,nx.diameter(k))
    avg.append(nx.average_shortest_path_length(k))
  diameter_value.append(dia)
  avg_path_length.append(mean(avg))
  triangle_count.append(sum(nx.triangles(test.G).values())/3)
  triangles = [c for c in nx.cycle_basis(test.G) if len(c)==3]
  triangle_types=[]
  for triangle in triangles:
      tri=nx.subgraph(test.G,triangle)
      triangle_types.append(np.product([(x[2]['weight']) for x in tri.edges(data=True)]))
  pos_count = len(list(filter(lambda x: (x >= 0), triangle_types)))
  balanced_triangle_count.append(pos_count)
j = 0
axis[0,0].plot(values,edge_count,linestyle = sty[j],marker = 'o',label = '|E|')
axis[0,0].plot(values,positive_edge_count,linestyle = sty[j],marker = 's',label = '|E+|')
axis[0,0].legend()
axis[0,0].set_xlabel('n')
axis[0,1].plot(values,clustering_coefficient,linestyle = sty[j],marker = 'o',label = 'c')
axis[0,1].legend()
axis[0,1].set_xlabel('n')
axis[1,0].plot(values,diameter_value,linestyle = sty[j],marker = 'o',label = 'd')
axis[1,0].plot(values,avg_path_length,linestyle = sty[j],marker = 's',label = 'l')
axis[1,0].legend()
axis[1,0].set_xlabel('n')
axis[1,1].plot(values,triangle_count,linestyle = sty[j],marker = 'o',label = '|\u0394|')
axis[1,1].plot(values,balanced_triangle_count,linestyle = sty[j],marker = 's',label = '|\u0394_b|')
axis[1,1].legend()
axis[1,1].set_xlabel('n')
plt.show()









