# -*- coding: utf-8 -*-
"""LBP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J4JC_vniWXRHuC4vZqIKihTw_lssFvVK

Installing Modules
"""



"""Importing Modules"""

import networkx as nx
import matplotlib.pyplot as plt
import matplotx
import numpy as np
import random

"""Setting Parameters"""



class interaction_based_model:
  def __init__(self, t, M_L, M_G, p_L, p_G, evap, n, delta):
    self.t = t
    self.M_L = M_L
    self.M_G = M_G
    self.p_L = p_L
    self.p_G = p_G
    self.evap = evap
    self.n = n
    self.delta = delta
    self.G = nx.Graph()
    self.G.add_nodes_from(range(0, n))

  def global_interactions(self, i):
    for x in range(0, self.M_G):
      degrees = [val for (node, val) in self.G.degree()]
      total = sum(degrees)
      prob = [(degree + 1)/ (total + self.n) for degree in degrees]

      u = i

      while u==i:
        u = np.random.choice(np.arange(0, self.n), p=prob)

      temp = np.random.choice(np.arange(0, 2), p = [self.p_G, 1 - self.p_G])

      if temp:
        if self.G.has_edge(u, i):
          self.G[u][i]['weight'] -= self.delta

        else:
          self.G.add_edge(u, i, weight= -1*(self.delta))

      else:
        if self.G.has_edge(u, i):
          self.G[u][i]['weight'] += self.delta

        else:
          self.G.add_edge(u, i, weight=self.delta)

  def local_interactions(self, i):
    for x in range(0, self.M_L):
      random_vertex = i
      adjacent_vertices = [n for n in self.G.neighbors(i)]
      for j in adjacent_vertices:
        if self.G[i][j]['weight'] == 0:
          self.G.remove_edge(i,j)
      if self.G.degree[i]:
        adjacent_vertices = [n for n in self.G.neighbors(i)]
        weight_adjacent_vertices = [abs(self.G[i][neighbour]['weight']) for neighbour in adjacent_vertices]
        total = sum(weight_adjacent_vertices) 
        prob = [x/total for x in weight_adjacent_vertices]
        random_vertex = np.random.choice(adjacent_vertices, p=prob) 
      else:
        lst = [j for j in range(0, self.n)]
        lst.remove(i)
        u = np.random.randint(0, self.n-1)
        random_vertex = lst[u]
        self.G.add_edge(random_vertex, i, weight=0)
      random_vertex2 = random_vertex
      adjacent_vertices = [n for n in self.G.neighbors(random_vertex)]
      adjacent_vertices.remove(i)
      for j in adjacent_vertices:
        if self.G[random_vertex][j]['weight'] == 0:
          self.G.remove_edge(random_vertex,j)
      if self.G.degree[random_vertex]>1:
        adjacent_vertices = [n for n in self.G.neighbors(random_vertex)]
        adjacent_vertices.remove(i)
        adjacent_vertices = [n for n in self.G.neighbors(random_vertex)]
        weight_adjacent_vertices = [abs(self.G[random_vertex][neighbour]['weight']) for neighbour in adjacent_vertices]
        total = sum(weight_adjacent_vertices) 
        prob = [x/total for x in weight_adjacent_vertices]
        random_vertex2 = np.random.choice(adjacent_vertices, p=prob)        
      else:
        lst = [j for j in range(0, self.n)]
        lst.remove(i)
        lst.remove(random_vertex)
        u = np.random.randint(0, self.n-2)
        random_vertex2 = lst[u]
        self.G.add_edge(random_vertex2, random_vertex, weight=0) 

      temp1 = np.random.choice(np.arange(0, 2), p = [self.p_L, 1 - self.p_L])
      
      if temp1:
        self.G[random_vertex][i]['weight'] -= self.delta
      else:
        self.G[random_vertex][i]['weight'] += self.delta

      temp2 = np.random.choice(np.arange(0, 2), p = [self.p_L, 1 - self.p_L])

      if temp2:
        self.G[random_vertex][random_vertex2]['weight'] -= self.delta
      else:
        self.G[random_vertex][random_vertex2]['weight'] += self.delta
      
      temp3 = 1
      if (temp1 == 1 and temp2 == 1) or (temp1 == 0 and temp2 == 0):
        temp3 = 0

      if temp3:
        if self.G.has_edge(random_vertex2, i):
          self.G[random_vertex2][i]['weight'] -= self.delta

        else:
          self.G.add_edge(random_vertex2, i, weight= -1*(self.delta))

      else:
        if self.G.has_edge(random_vertex2, i):
          self.G[random_vertex2][i]['weight'] += self.delta

        else:
          self.G.add_edge(random_vertex2, i, weight=self.delta)

  def evaporation(self):
    thingsToChange = []
    for v1, v2, data in self.G.edges(data=True):
      if abs(self.G[v1][v2]['weight']) <= self.evap:
        thingsToChange.append([v1,v2])
      elif data['weight']>0:
        self.G[v1][v2]['weight'] -= self.evap
      else:
        self.G[v1][v2]['weight'] += self.evap
      
    for thing in thingsToChange:
      self.G.remove_edge(thing[0],thing[1])  

  def main_function(self):
    for n in range(0, self.t):
      for i, data in self.G.nodes(data=True):
        self.global_interactions(i) 
        self.local_interactions(i)  
      if n%10==0:
          print(n)
          print("EV")
      self.evaporation()



"""PLOTTING GRAPHS FOR - 
1. Number of edges and number of positive edges
2. Clustering Coefficient
3. Diameter and average path length
4. Number of triangles and balanced triangles
"""

from statistics import mean
values = [i for i in range(1, 10)]
connected_components_count = []
for j in range(0,len(values)):
  test = interaction_based_model(150,5,1,0.6,0.9, 0.5,values[j]*10000, 1)
  test.main_function()
  sz = nx.number_connected_components(test.G)
  connected_components_count.append(sz)
plt.plot(values, connected_components_count)
plt.xlabel('Number of nodes(in ten thousands)')
plt.ylabel('Number of connected components')
plt.title('Varying n')
plt.show()









